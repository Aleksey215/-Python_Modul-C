# Контекстные менеджеры. Ключевое слово with, принципы создания собственных контекстных менеджеров.

# Контекстный менеджер — определенная структура в языке Python (класс или генератор),
# основывающаяся на главном принципе: при его открытии и закрытии срабатывает заранее написанный программистом код.

# Открытие происходит при входе в блок с помощью ключевого слова with.
# Закрытие происходит, когда блок заканчивается. Например, на входе — открывается файл, на выходе — закрывается.

# with open("file.bin", "wt") as f: # открываем файл с помощью with
#     f.write("abcdefg")

# Чтобы написать контекстный менеджер нужно всего лишь помнить о нескольких вещах:
#         Нужно создать класс и написать в нём метод __enter__.
#         Код в этом методе будет выполняться при входе в контекстный менеджер
#         (при создании объекта с ключевым словом with).

#         Написать метод __exit__. Этот метод будет выполнять код, помещённый в него, на выходе.

#         Добавить в этот метод три дополнительных аргумента помимо self — exc_type, exc_val, exc_tb.

# Ну а сейчас давайте попробуем написать простенький измеритель времени исполнения нашего кода:

from datetime import datetime
import time


class Timer:
    def __init__(self):
        pass

    # этот метод вызывается при запуске с помощью with.
    # Если вы хотите вернуть какой-то объект, чтобы потом работать с ним в контекстном менеджере,
    # как в примере с файлом, то просто верните этот объект через return
    def __enter__(self):
        self.start = datetime.utcnow()
        return None

    def __exit__(self, exc_type, exc_val, exc_tb):  # этот метод срабатывает при выходе из контекстного менеджера
        print(f"Time passed: {(datetime.utcnow() - self.start).total_seconds()}")


print("Контекстный менеджер через класс")
with Timer():
    time.sleep(2)
print()


# В дополнение к комментариям в коде ещё хотелось бы сказать пару слов об аргументах метода __exit__.

# exc_type — это тип исключения, из-за которого вылетел контекстный менеджер.
# Если всё прошло успешно, то значение этого аргумента будет None.

# exc_val — сообщение в исключении. Аналогично: если всё прошло успешно, этот аргумент будет None.

# exc_tb — объект сообщения от интерпретатора. Лучшего его вообще не трогать, если вы не разработчик языка

# По сути, здесь разница только в том, что контекстный менеджер на генераторах — это функция
# В ней до yield выполняется код, который мы могли бы записать в __enter__,
# если бы делали контекстный менеджер в виде класса,
# а после yield пишем код, который выполнился бы в __exit__.
# То есть до yield — всё что произойдёт при входе, после — всё, что на выходе.
# Вот и вся разница. Как видите, она не велика.

from contextlib import contextmanager


@contextmanager
def timer():
    start = datetime.utcnow()
    yield
    print(f"Time passed: {(datetime.utcnow() - start).total_seconds()}")


print("Контекстный менеджер через генератор")
with timer():
    time.sleep(3)
print()

print("Задание 3.5.6")
# Напишите контекстный менеджер, который умеет безопасно работать с файлами.
# В конструктор объекта контекстного менеджера передаются два аргумента:
# первый — путь к файлу, который надо открыть, второй — тип открываемого файла (для записи, для чтения и т. д.).
#
# При входе в контекстный менеджер должен открываться файл, и возвращаться объект для работы с этим файлом.
# При выходе из контекстного менеджера файл должен закрываться.
# (Эталоном работы можно считать контекстный менеджер open).


class OpenFile:
    def __init__(self, path, type):
        self.file = open(path, type)

    def __enter__(self):
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file.close()


with OpenFile('hello.txt', 'wt') as f:
    f.write('Мой контекстный менеджер делает тоже самое!')
