# API (Application programming interface) — это набор публичных свойств и методов для взаимодействия
# с другими программами, которые могут быть написаны даже на другом языке программирования.
# API можно определить как: «Ко мне можно обращаться так и так, я обязуюсь делать то и это».

# отправим GET-запрос:
import requests
import json


r = requests.get('https://baconipsum.com/api/?type=all-meat&paras=3&start-with-lorem=1&format=html')
# сервер по переданному адресу
print(r.content)
# В результате работы данного кода в консоль выведется HTML-код сгенерированного текста,
# т. к. запрос на получение странички через браузер на самом деле эквивалентен вызову функции .get()

# возможно собирать просто огромные данные с тех же самых страниц,
# не заходя на них и оставив скрипт работать в фоновом режиме.
# Именно для этого и нужна библиотека Requests.

# программы, которые забирают и сохраняют главную информацию с каких-либо сайтов, называются парсерами
#  чтобы получить содержание ответа надо обратится к полю content объекта response, который возвращается,
#  когда приходит ответ от сервера через библиотеку Requests.
# У этого объекта, на самом деле, есть много полей, например,
# status_code, который говорит нам о том, какой вообще ответ
print(r.status_code)
# Есть несколько категорий ответов, например:
#         200, 201, 202 и т. д. — ответы, которые говорят, что с запросом всё хорошо,
#         и ответ приходит правильный, т. е. его можно обрабатывать и как-либо взаимодействовать с ним.
#         На самом деле почти все серверы всегда в ответ шлют именно ответ 200,
#         а не какой-либо другой из этой же категории.

#         300, 301 и т. д. — ответы, которые говорят, что вы будете перенаправлены на другой ресурс
#         (не обязательно на этом же сервере).

#         400, 401 и т. д. — ответы, которые говорят, что что-то неправильно с запросом.
#         Запрашивается либо несуществующая страница (всем известная 404 ошибка),
#         либо же недостаточно прав для просмотра страницы (403) и т. д.

#         501, 502 и т. д. — ответы, которые говорят, что с запросом всё хорошо,
#         но вот на сервере что-то сломалось, и поэтому нормальный ответ прийти не может.

# Информацию с сайта мы можем получать не только в виде HTML, но и в формате JSON.
# JSON переводится как JavaScriptObjectNotation.
# Это определённый тип ответов от сервера, который уже содержит только нужную нам информацию,
# без всяких HTML-кодов.
# По сути своей JSON очень похож на структуры данных в Python (словари и списки)
r1 = requests.get("https://baconipsum.com/api/?type=meat-and-filler")
print(r1.content)
# Если приглядеться, то здесь можно увидеть нечто похожее на список в Python.
# Однако, чтобы использовать полученный ответ как Python-объект,
# надо воспользоваться дополнительной библиотекой, которая упрощает работу
# с JSON-ответами и может легко переконвертировать ответ от сервера в
# Python-объекты, с которыми удобно работать.
r = requests.get('https://baconipsum.com/api/?type=meat-and-filler')
texts = json.loads(r.content)  # делаем из полученных байтов Python-объект для удобной работы
print(type(texts))  # проверяем тип сконвертированных данных

for text in texts:  # выводим полученный текст. Но для того чтобы он влез в консоль, оставим только первые 50 символов.
    print(text[:50], '\n')
# Теперь мы сделали ответ от сервера списком — структурой данных Python,
# с которой гораздо приятнее работать, чем просто с байтами.


# Давайте посмотрим теперь на ещё один тип возвращаемых значений.
# Он тоже будет JSON, но в данном случае он скорее будет похож на словарь.
r = requests.get('https://api.github.com')
print(r.content)
# Дело в том, что на самом деле это не совсем словарь.
# JavaScriptObjectNotation (он же JSON) есть ничто иное, как правило записи JS-объектов в файл,
# чтобы сохранять их состояния и затем загружать обратно в программу.
# В модуле JSON, а конкретно в функции loads, за нас уже заранее обо всём позаботились.
# В зависимости от вида полученного ответа от сервера JSON-функция сама будет обрабатывать
# его и возвращать нужный нам объект (список или словарь).

# теперь сделаем его настоящим словарём.
r = requests.get('https://api.github.com')
d = json.loads(r.content)  # делаем из полученных байтов Python-объект для удобной работы
print(type(d))
print(d['following_url'])  # обращаемся к полученному объекту как к словарю и попробуем напечатать одно из его значений
# Таким образом мы можем удобно превращать данные полученные из ответа JSON
# в объекты структур данных Python с помощью библиотеки JSON и удобно работать с ними.

# Как вы могли заметить, здесь мы использовали только GET-запросы (применяли функцию .get() из библиотеки requests).
# Однако одним из наиболее распространённых запросов помимо GET является POST-запрос.
# Если же GET используется как правило для получения данных
# (например, JSON-ответ или HTML-код для браузера, как мы уже увидели),
# то при помощи POST-запросов отправляются данные для обработки на сервер.
# Например, чаще всего вместе с POST-запросом используются параметры (data)
# для записи каких-либо новых данных в базу данных.

r = requests.post('https://httpbin.org/post', data={'key': 'value'})  # отправляем пост-запрос
print(r.content)  # содержимое ответа и его обработка происходит так же, как и с ГЕТ-запросами, разницы никакой нету
# Это простенькое API копирует наш запрос и выводит о нём главную информацию.

# Давайте посмотрим, как с помощью уже знакомой нам библиотеки отправить данные в нужном нам формате:
data = {'key': 'value'}
r = requests.post('https://httpbin.org/post', json=json.dumps(data))  # отправляем пост-запрос,
# но только в этот раз тип передаваемых данных будет JSON
print(r.content)

print('Задание 5.2.3')
# Напишите программу, которая отправляет запрос на генерацию случайных текстов (используйте этот сервис).
# Выведите первый из сгенерированных текстов.
r = requests.get('https://baconipsum.com/api/?type=meat-and-filler')

r = json.loads(r.content)

print(r[0])
