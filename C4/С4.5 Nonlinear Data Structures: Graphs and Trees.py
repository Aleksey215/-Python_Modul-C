# ***** Графы *****

# Граф — это структура, имеющая узлы (вершины графа) и связи между ними (ребра).
# важно сейчас понимать, как могут быть представлены графы в памяти компьютера.
# Первый способ представления называется матрица смежности.
# В матрице смежности (двумерном массиве) каждая строка и каждый столбец соответствуют вершине.
# На пересечении столбца x и строки y стоит 1, если эти две вершины x и y соединены ребром, иначе стоит ноль.
# Такой способ представления является эффективным, если граф является плотным — в нем много рёбер.
# Однако он сильно теряет в эффективности, если в нем присутствует большое количество вершин, но мало ребер.

# Второй способ представления — список смежности.
# Существует много реализаций графов списком смежности.
# Основная суть сводится к тому, чтобы хранить массив (список, словарь) связанных списков.
# Каждый внутренний список, в свою очередь, хранит вершины, с которыми имеет связь вершина, образующая список.
# Список смежности легко реализуется с помощью двух встроенных типов Python — словарь (dict) и список (list).
# Пример:
# G = {0 : [1, 2, 3],  вершина 0, связана с вершинами 1, 2, 3
#      1 : [0, 2],     вершина 1, связана с вершинами 0, 2
#      2 : [0, 1],     вершина 2, связана с вершинами 0, 1
#      3 : [0]}        вершина 3, связана с вершиной 0
# Большинство необходимых операций с этими структурами имеют невысокую сложность по сравнению с двумерным массивом.

print("Задание 4.5.1")
# Представьте эту часть схемы в виде графа и создайте список смежности, используя словарь.
G = {
    'Адмиралтейская': ['Садовая'],
    'Садовая': ['Сенная площадь', 'Спасская', 'Адмиралтейская', 'Звенигородская'],
    'Сенная площадь': ['Садовая', 'Спасская'],
    'Спасская': ['Садовая', 'Сенная площадь', 'Достоевская'],
    'Звенигородская': ['Пушкинская', 'Садовая'],
    'Пушкинская': ['Звенигородская', 'Владимирская'],
    'Достоевская': ['Владимирская', 'Спасская'],
    'Владимирская': ['Достоевская', 'Пушкинская']
}
# Граф, помимо прочего, может быть взвешенным — каждое ребро может иметь свой вес в графе.
# Такой граф можно представить в виде словаря словарей, где значение ключа представляет собой вес ребра.
# G = {0 : {1 : 1,
#           2 : 1,
#           3 : 1},
#      1 : {0 : 1,
#           2 : 1},
#      2 : {0 : 1,
#           1 : 1},
#      3 : {0 : 1}}
G1 = {
    'Адмиралтейская': {'Садовая': 4},
    'Садовая': {'Сенная площадь': 4, 'Спасская': 3, 'Адмиралтейская': 4, 'Звенигородская': 5},
    'Сенная площадь': {'Садовая': 4, 'Спасская': 4},
    'Спасская': {'Садовая': 3, 'Сенная площадь': 4, 'Достоевская': 6},
    'Звенигородская': {'Пушкинская': 3, 'Садовая': 5},
    'Пушкинская': {'Звенигородская': 3, 'Владимирская': 4},
    'Достоевская': {'Владимирская': 3, 'Спасская': 6},
    'Владимирская': {'Достоевская': 3, 'Пушкинская': 4}
}

# При работе с графами одна из наиболее частых задач — поиск кратчайшего пути от одной вершины к другой.
# Сейчас мы с вами попытаемся реализовать алгоритм, позволяющий найти его.
# Он носит название «алгоритм Дейкстры»

# Его суть заключается в том, чтобы последовательно перебирать вершины одну за другой
# в поисках кратчайшего пути до этой вершины.
# Вершину будем называть предком для другой, если она идет раньше по пути перемещения по ребрам в графе.
# Ближайший предок — это предок, имеющий прямую связь (ребро) с рассматриваемой.
# Рассмотрим этот алгоритм также на примере взвешенного графа станций метро из последней задачи.

# Для начала нам потребуется дополнительная структура данных для хранения расстояний.
# Если вершины пронумерованы числами, то можно использовать массив,
# но т. к. мы имеем проименованные узлы, то удобнее пользоваться словарем.

# D = {k: 100 for k in G1.keys()}

# Проинициализируем словарь расстояний числами, которые заведомо больше максимального расстояния в графе.
# Значения 100 в данной задаче нам будет более чем достаточно.
# Одну из вершин мы должны выбрать как стартовую.
# Поэтому стартовая вершина будет предком для всех остальных.
# Расстояние для нее (от нее же самой) будет равно нулю.
# Пусть это будет «Адмиралтейская».

# D["Адмиралтейская"] = 0

# Также нам потребуется хранить словарь с булевыми значениями,
# в котором True — если вершина просмотрена, иначе — False.

# U = {k: False for k in G1.keys()}

# Далее мы должны пройти циклом из n итераций, выбирая вершину с наименьшим D среди непросмотренных.
# Очевидно, что на первой итерации будет выбрана стартовая вершина.
# Из нее мы должны проверить все вершины, в которые можем перейти, и в D записать наименьшее расстояние до них.
# Пока что мы можем идти только из стартовой вершины, поэтому запишутся именно эти расстояния.
# Стартовая вершина станет помеченной как уже просмотренная. После чего начнется поиск вершины с минимальным D
# из уже просмотренных (куда можно добраться из стартовой).
# От нее также будут строится возможные ребра и проверяться минимум расстояний.
# И так далее, пока процесс не завершится.
# Утверждается, что достаточно числа итераций равного количеству вершин.
# При достижении этого алгоритм завершится корректно.
D = {k: 100 for k in G1.keys()}
start_k = "Адмиралтейская"
D[start_k] = 0
U = {k: False for k in G1.keys()}
P = {k: None for k in G1.keys()}

for _ in range(len(D)):
    min_k = min([k for k in U.keys() if not U[k]], key=lambda x: D[x])
    for v in G1[min_k].keys():
        if D[v] > D[min_k] + G1[min_k][v]:
            D[v] = D[min_k] + G1[min_k][v]
            P[v] = min_k
    U[min_k] = True

for key in D.keys():
    print(key, D.get(key))
print("-------")
for key in P.keys():
    print(f"{P.get(key)} -> {key}")
# В нем отражено кратчайшее расстояние от «Адмиралтейской» до станции, которая задает ключ.

# Алгоритм Дейкстры можно модифицировать таким образом, что можно определить не только величину пути,
# но еще и сами вершины минимального пути.
# Для этого определим еще один словарь P,
# в котором будем для каждой вершины хранить вершину-предок с минимальным расстоянием.
# P = {k: None for k in G1.keys()}

print("Задание 4.5.3")
# Модифицируйте алгоритм Дейкстры таким образом, что в массив P по соответствующему ключу
# будет записываться предок с минимальным расстоянием, если это необходимо.



# *** Деревья ***
# Один из наиболее часто используемых подвидов графов — это деревья.
# Чтобы граф считался деревом, необходимо выполнение нескольких условий:
#   1. Граф должен быть связным — не должно присутствовать вершин без ребер.
#   2. Должны отсутствовать циклы.
#   3. Часто под деревьями подразумеваются только неориентированные и невзвешенные графы.

# При соблюдении этих условий граф можно визуально представить в виде структуры, напоминающей обычное дерево.
# Только, как правило, оно «растёт» вниз.

# В дереве можно выделить:
#   корневой узел;
#   потомки;
#   лист или терминальный узел — узел, не имеющий потомков;
#   внутренние узлы — некорневые узлы, имеющие хотя бы одного потомка.

# В зависимости от максимального количества потомков в одной вершине различают:
#   бинарные;
#   тернарные деревья;
#   n-арные деревья (с максимальным количеством потомков n);
#   2-3 деревья, 2-3-4, в которых помимо увеличенного количества потомков
#   в самом узле может храниться больше данных.

# Итак, рассмотрим бинарное дерево. Основное его свойство заключается в том,
# что у каждого узла может быть не более 2 потомков — соответственно, левый и/или правый.
# В нашей структуре данных, в каждом узле бинарного дерева мы будем хранить указатель на левого и правого потомка.
class BinaryTree:
    def __init__(self, value):
        self.value = value
        self.left_child = None
        self.right_child = None
    # Мы создали класс узла, в конструкторе которого записали значение, которое должно храниться в нем.
    # Также инициализировали левого и правого потомка.
    # Пока что в них ничего не хранится — нужно иметь процедуру вставки новых элементов.
    # Напишем разные методы для вставки на место левого потомка и на место правого потомка.

    def insert_left(self, next_value):
        if self.left_child is None:
            self.left_child = BinaryTree(next_value)
        else:
            new_child = BinaryTree(next_value)
            new_child.left_child = self.left_child
            self.left_child = new_child
        return self
    # Если в текущем узле нет левого потомка, то новый узел вставляем на его место,
    # если левый потомок уже существует — он становится таким же левым потомком,
    # но уже нового узла.
    # Иными словами, он остается левым, но его глубина увеличивается.

    def insert_right(self, next_value):
        if self.right_child is None:
            self.right_child = BinaryTree(next_value)
        else:
            new_child = BinaryTree(next_value)
            new_child.right_child = self.right_child
            self.right_child = new_child
        return self
    # В обоих случаях мы возвращаем ссылку на текущий узел.
    # Это нам необходимо, чтобы создавать цепочки действий.
    # Рассмотрим на примере:

    def pre_order(self):
        print(self.value)  # процедура обработки
        if self.left_child is not None:  # если левый потомок существует
            self.left_child.pre_order()  # рекурсивно вызываем функцию

        if self.right_child is not None:  # если правый потомок существует
            self.right_child.pre_order()  # рекурсивно вызываем функцию

    # Задание 4.5.6
    def post_order(self):
        if self.left_child is not None:  # если левый потомок существует
            self.left_child.post_order()  # рекурсивно вызываем функцию

        if self.right_child is not None:  # если правый потомок существует
            self.right_child.post_order()  # рекурсивно вызываем функцию

        print(self.value)  # процедура обработки

    def in_order(self):
        if self.left_child is not None:
            self.left_child.in_order()

        print(self.value)

        if self.right_child is not None:
            self.right_child.in_order()


A_node = BinaryTree('A').insert_left('B').insert_right('C')

# Реализуйте структуру дерева при помощи класса BinaryTree.
root = BinaryTree(2).insert_left(7).insert_right(5)
node_7 = root.left_child.insert_left(2).insert_right(6)
node_6 = node_7.right_child.insert_left(5).insert_right(11)
node_5 = root.right_child.insert_right(9)
node_9 = node_5.right_child.insert_left(4)

# *** Обход дерева ***
# В случае дерева нелинейная структура требует развития особых подходов в обходе по нему.
# Различают два основных способа обхода:
#   1. Поиск в глубину (depth-first search, DFS).
#      Его основная суть заключается в том, что проходя по каждому узлу мы сначала идем в его потомка,
#      а потом возвращаемся обратно — это обход с возвратом. Такой поиск бывает трех видов:
#          1.1 префиксный (pre-order);
#          1.2 постфиксный (post-order);
#          1.3 инфиксный (in-order).
#   2. Поиск в ширину (breadth-first search, BFS). Такой обход осуществляется в обходе уровня за уровнем.

# Начнем с рассмотрения поиска в глубину.
# В обходе в глубину мы всегда используем рекурсивный подход:
# префиксный, постфиксный или инфиксный, подходы отличаются лишь порядком
# выполнения процедуры обработки узла и вызовов этой же функции на потомках.

# Рассмотрим префиксный подход.
# Сначала мы должны обработать значение самого узла (поэтому он и префиксный),
# а затем рекурсивно проделать тоже самое с левым потомком и затем с правым.
# В качестве процедуры обработки узла возьмем самое простое — печать его значения.

# Давайте посмотрим в каком порядке будет производиться префиксный обход дерева в глубину
# на примере созданного нами дерева.

root.pre_order()
# Сначала мы записали значение корневого узла (2), после чего — его левого потомка (7).
# У него также есть левый потомок (2), который является листом,
# поэтому происходит возврат на предыдущий уровень — печатается значение правого потомка (6).
# Дальше просматриваются его потомки, и происходит возврат до того уровня,
# который не просмотрен — правое поддерево корневого узла (/|2|5\).

print()
root.post_order()

# Инфиксный подход заключается в том, что порядок обработки узла и его потомков смешивается:
# сначала шагаем в левое поддерево, потом обрабатываем сам узел, затем правое поддерево.
# В итоге получается, что мы как будто «читаем» дерево слева направо.
print()
root.in_order()