# ***** Основные структуры данных: список, стек, очередь *****

# *** Списки: односвязные и двусвязные ***
# список как структуру данных стоит отличать от одноименного типа данных в Python.
# Что называется list (список) в Python — является динамическим массивом.
# Далее под списком будет пониматься именно «список как структура данных».

# Список — это также упорядоченный набор элементов.
# Однако, в отличие от массива, который хранится последовательно в одной области памяти,
# и каждой ячейке линейно соответствует определенный индекс, список может быть хаотично распределен в памяти.
# Порядок в этой структуре данных задается наличием указателей на следующий (и/или предыдущий) элемент в списке.

# Если в каждой ячейке памяти хранится указатель только на следующий элемент,
# то список называется односвязным.
# Если указатель и на предыдущий и на следующий — имеем двусвязный список.

# Способ хранения списков имеет свои плюсы и минусы.

# Вставка элемента в конец списка.
# Происходит за константное время, если в первой ячейке хранится указатель на последний элемент.
# Иначе требуется проход по всем элементам до последнего, что потребует O(n) операций.
# Действительно, мы можем вставить элемент на последнее место,
# изменив указатель в первой ячейке, чтобы он указывал на новый элемент.

# Вставка элемента в начало.
# Может быть произведена за константное время, ведь достаточно
# в новом элементе вставить указатель на тот, что был первым,
# и дописать указатель на последний элемент.

# В списке также можно вставить элемент на произвольное место.
# В отличие от массива, в списках нет необходимости перемещать элементы,
# однако здесь эту операцию все равно можно сделать асимптотически за O(n) в худшем случае.
# Дело в том, что для поиска нужного положения нового элемента
# придется пройтись от первого указателя до необходимого положения в списке.
# И, например, для вставки элемента на n-1 индекс
# нужно будет пройти все элементы от 0-го до n-1-го и только после этого производить вставку.

# Удаление элемента из начала.
# Производится за константное время.
# Как и в первых двух случаях, нужно всего лишь изменить положение нужных указателей.

# Удаление элемента из произвольного места.
# Занимает линейное время.
# Ответ кроется в том, что нужный элемент требуется найти (по «индексу» или значению)
# проходом от 0-го до искомого элемента.
# И даже в случае удаления последнего элемента мы вынуждены пройти весь список,
# чтобы в первую ячейку записать обновленный указатель на последний элемент.
# Такой проблемы в двусвязных списках, очевидно, нет.

# Расширение списка.
# Благодаря такому способу хранения не требует переносов всей структуры в другую область памяти,
# как это было в случае динамических массивов, поэтому добавление к первому списку
# размера n элементов списка размера m потребует только O(m) времени.

# Общий размер списка.
# может храниться в самой структуре, и тогда его можно узнать за константное время,
# но это требует дополнительной памяти.
# Если в конкретной реализации списка не предусмотрено хранение размера,
# то пересчет элементов займет O(n) операций.

# Таким образом можно сказать, что список наиболее удобен,
# когда нужно обрабатывать элементы в определенном порядке без использования индексации.

# *** Стек (stack) ***
# есть упорядоченный набор элементов (прямо как массив или список),
# но производится всегда две операции — взять сверху или положить сверху.
# Как вы уже наверное догадались — это стек.

print("Задание 4.4.1")
# Убедитесь в этом самостоятельно, написав функцию p(n),
# вызывающей эту же самую функцию с аргументом, уменьшенным на единицу,
# и после чего печатающей значение аргумента.
# Обратите внимание на описанный порядок действий и наличие условие выхода из рекурсии.


def p(n):
    if n == 0:
        return
    else:
        p(n-1)
        print(n)


p(5)

# Здесь мы видим, что сначала выполнились действия последней функции в порядке вызовов,
# затем предпоследней и т. д., пока не дойдем до первого.
# Такой принцип имеет общепринятое название — LIFO — Last In First Out
# (последний вошел — первый вышел). И именно этот принцип реализует стек.

# Иными словами, стек — это структура данных, реализующая LIFO.

# Вставка элемента в стек (push)
# Работает за O(1), если стек реализован через список и,
# в среднем, также O(1), если реализован через динамический массив.

# Удаление верхнего элемента из стека (pop)
# Также как и вставка, удаление верхнего элемента происходит за O(1).
# Действительно, в массиве удаление последнего элемента происходит за константное время,
# как и в списке, если он двусвязный.

# Получение значения последнего элемента без удаления (top)
# Аналогично предыдущим операциям получение значения последнего элемента происходит за O(1).

# Общий размер стека (size)
# Здесь уже всё зависит от реализации.
# В случае односвязного списка O(1), если это значение хранится в самой структуре или O(n),
# если нужен проход по всем элементам для их пересчета.
# В массиве операция получения размера занимает константное время.

# Пример применения стека
# Наличие любой открытой, но не закрытой скобки является ошибкой.
# Ровно как и наличие закрывающей скобки без открывающей.
# Напишем функцию par_checker(string), которая проверяет строку string на корректность расстановки скобок.
def par_checker(string):
    stack = []  # инициализируем стек

    for s in string:  # читаем строку посимвольно
        if s == "(":  # если открывающая скобка,
            stack.append(s)  # добавляем ее в стек
        elif s == ")":
            # если встретилась закрывающая скобка, то проверяем
            # пуст ли стек и является ли верхний элемент - открывающей скобкой
            if len(stack) > 0 and stack[-1] == "(":
                stack.pop()  # удаляем из стека
            else:  # иначе завершаем функцию с False
                return False
    # если стек пустой, то незакрытых скобок не осталось
    # значит возвращаем True, иначе - False
    return len(stack) == 0


print("Задание 4.4.5")
# Модифицируйте функцию проверки баланса скобок для двух видов скобок: круглых и квадратных.
# Для реализации такого алгоритма может быть полезным создание словаря,
# в котором закрывающая скобка — ключ, открывающая — значение.
def par_checker_2(string):
    stack = {}
    for s in string:
        if s == "(":
            stack[")"] = s
        elif s == "[":
            stack["]"] = s
        elif s == ")":
            if len(stack) > 0 and stack[")"] == "(":
                stack.pop(")")
            else:
                return False
        elif s == "]":
            if len(stack) > 0 and stack["]"] == "[":
                stack.pop("]")
            else:
                return False
    return len(stack) == 0


print(par_checker_2('()[]'))

# by skillfactory
# pars = {")" : "(", "]" : "["}
#
# def par_checker_mod(string):
#     stack = []
#
#     for s in string:
#         if s in "([":
#             stack.append(s)
#         elif s in ")]":
#             if len(stack) > 0 and stack[-1] == pars[s]:
#                 stack.pop()
#             else:
#                 return False
#     return len(stack) == 0


# *** Очередь ***
# Другой вид последовательности, который скорее всего более привычен в бытовом смысле — это очередь.
# В отличие от стека он работает по принципу FIFO — First In First Out (первый вошел — первый вышел).
# Прямо как в любимой всеми очереди к врачу, например.

# Очередь может быть реализована как на массивах, так и на списках.
# В связи с наличием динамического массива в Python (list) попробуем построить очередь,
# используя эту структуру данных.
# Она имеет своё ограничение из-за того, что удаление из конца или вставка элемента в начало имеют сложность O(n).

# Чтобы обойти это ограничение, зафиксируем несколько свойств очереди:
#   Определим максимальную длину очереди — N_max.
#   При переполнении будем запрещать добавление элементов в очередь.
#   Зафиксируем два указателя:  head (начало) и tail (хвост) очереди.
#   Закольцуем очередь таким образом, что если указатель tail >= n_max, то мы перемещаем его в начало.

# Для очереди можно определить несколько операций:
#
#         Вставка элемента в хвост очереди (push).
#         Получение элемента из начала очереди (top).
#         Удаление элемента из начала очереди (pop).
#         Проверка наличия элементов в очереди (is_empty).
#         Получение размера очереди (size).
#
# Все они выполняются за O(1). И это то, что нужно!

# Попробуем создать обработчик задач на бесконечном цикле с использованием очереди:
# Создадим класс Queue - нужная нам очередь
class Queue:
    # Конструктор нашего класса, в нём происходит нужная инициализация объекта
    def __init__(self, max_size):
        self.max_size = max_size  # размер очереди
        self.task_num = 0  # будем хранить сквозной номер задачи

        self.tasks = [0 for _ in range(self.max_size)]  # инициализируем список с нулевыми элементами
        self.head = 0  # указатель на начало очереди
        self.tail = 0  # указатель на элемент следующий за концом очереди

    # !!! Класс далее нужно дополнить методами !!!
    def is_empty(self):
        return self.head == self.tail and self.tasks[self.head] == 0

    def size(self):  # получаем размер очереди
        if self.is_empty():  # если она пуста
            return 0  # возвращаем ноль
        elif self.head == self.tail:  # иначе, если очередь не пуста, но указатели совпадают
            return self.max_size  # значит очередь заполнена
        elif self.head > self.tail:  # если хвост очереди сместился в начало списка
            return self.max_size - self.head + self.tail
        else:  # или если хвост стоит правее начала
            return self.tail - self.head

    def add(self):
        pass





# Используем класс
# size = int(input("Определите размер очереди: "))
q = Queue(3)
print(q.tasks)
print(q.size())
print(q.is_empty())
#
# while True:
#     cmd = input("Введите команду:")
#     if cmd == "empty":
#         if q.is_empty():
#             print("Очередь пустая")
#         else:
#             print("В очереди есть задачи")
#     elif cmd == "size":
#         print("Количество задач в очереди:", q.size())
#     elif cmd == "add":
#         if q.size() != q.max_size:
#             q.add()
#         else:
#             print("Очередь переполнена")
#     elif cmd == "show":
#         if q.is_empty():
#             print("Очередь пустая")
#         else:
#             q.show()
#     elif cmd == "do":
#         if q.is_empty():
#             print("Очередь пустая")
#         else:
#             q.do()
#     elif cmd == "exit":
#         for _ in range(q.size()):
#             q.do()
#         print("Очередь пустая. Завершение работы")
#         break
#     else:
#         print("Введена неверная команда")