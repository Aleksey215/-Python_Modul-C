# Декораторы класса: @property, @classmethod.
# Ещё пару слов о нашей бывшей возлюбленной — инкапсуляции.

# Инкапсуляция — это одна из основ объектно-ориентированного программирования, которая говорит нам о том,
# что поля (переменные) класса и его методы (функции класса) надо объединять в одну целую систему.

# @property очень классный декоратор, он-то, по сути, и обеспечивает нам прямой путь к инкапсуляции,
# позволяя объединить методы и поля.
# Давайте же скорее взглянем на пример кода с использованием этого декоратора.


class Dog:
    _happiness = 10

    def __init__(self, name, age):
        self.name = name
        self.age = age

    # создадим свойство human_age, которое будет переводить возраст животного в человеческий
    @property  # тот самый магический декоратор
    def human_age(self):
        return self.age * 7.3

    # создали геттер для поля _happiness
    @property
    def happiness(self):
        return self._happiness

    # с помощью декоратора setter мы можем неявно передать во второй
    # аргумент значение, находящееся справа от равно, а не закидывать это
    # значение в скобки, как мы это делали в модуле C1, когда не знали о
    # декораторах класса
    @happiness.setter
    def happiness(self, value):
        # допустим, мы хотим, чтобы счастье питомца измерялось шкалой от 0 до 100
        if value <= 100 and value >= 0:
            self._happiness = value
        else:
            raise ValueError("Happiness must be between 0 ... 100")


jane = Dog("Jane", 4)
# т.к. метод помечен декоратором property, то нам не надо вызывать этот метод чтобы получить результат
print(jane.human_age)
# В этом куске кода мы пометили декоратором @property метод human_age.
# В итоге мы смогли получить результат работы метода, не вызывая его явно
# (без декоратора нам бы пришлось дописать в конец его вызов).
# Как правило, на этом объяснение этого потрясающего декоратора и заканчивается, а очень даже зря.
# Ведь помимо неявного вызова метода, мы можем похожим образом устанавливать значение в поле.
# Давайте же дополним наш код ещё одним свойством — шкалой счастья.
# Для этого поля мы создадим геттер и сеттер.
jane.happiness = 100  # используем метод, задекорированный под сеттер
print(jane.happiness)  # используем геттер

# Вдобавок к комментариям в коде важно отметить, что декораторы .setter должны называться так же,
# как и метод, помеченный декоратором @property, для которого вы хотите устанавливать значение,
# иначе интерпретатор выдаст ошибку.
# для примера выше это happiness

# Благодаря декоратору @.setter можно использовать инкапсуляцию,
# сохраняя привычное нам обращение к полю через точку, а установку нового значения через =.
# Вот такой вот магический декоратор @property.

# Ну и напоследок стоит сказать пару слов о декораторе @classmethod.
# Который встречается довольно редко, ввиду его малой понятности для обывателей и синтаксической громоздкости.
# Используется он, как правило, чтобы открыть путь в полиморфизм


class ParentClass:

    @classmethod
    def method(cls, arg):
        print("%s classmethod. %d" % (cls.__name__, arg))

    @classmethod
    def call_original_method(cls):
        cls.method(5)

    def call_class_method(self):
        self.method(10)


class ChildClass(ParentClass):

    @classmethod
    def call_original_method(cls):
        cls.method(6)


# Вызываем методы класса через класс.
ParentClass.method(0)
ParentClass.call_original_method()

ChildClass.method(0)
ChildClass.call_original_method()

my_obj = ParentClass()
my_obj.method(1)
my_obj.call_class_method()
# Т. е., по сути, метод может вызываться, как через ParentClass, так и через ChildClass.
# Только в качестве первого аргумента передаётся не сам объект, а модель класса.
print()

print("Задание 2.3.4")
# Создать вычисляемое свойство для класса Square.
# Сделайте метод по вычислению площади свойством.
# Сделайте сторону квадрата свойством, которое можно установить только через сеттер.
# В сеттере добавьте проверку условия, что сторона должна быть неотрицательной.


class Square:
    _side = None

    def __init__(self, side):
        self.side = side

    @property
    def side(self):
        return self._side

    @side.setter
    def side(self, value):
        if value > 0:
            self._side = value
        else:
            raise ValueError("Сторона квадрата не может быть отрицательной или равно нулю")

    @property
    def area(self):
        return self.side ** 2


square_1 = Square(5)
print(square_1.side)
print(square_1.area)
square_1.side = 7
print(square_1.side)
print(square_1.area)

print()