# ***** Исключения *****
# Исключения — это такие ошибки, которые возникают не во время компиляции программы,
# а в процессе её исполнения, в случаях, если что-то идёт не так.

# Ошибки бывают двух видов:
# отлавливаемые — все, что наследуются от класса Exception
# не отлавливаемые — SystemExit, KeyboardInterrupt и т. д.

# print("Перед исключением")
# # теперь пользователь сам вводит числа для деления
# a = int(input("a: "))
# b = int(input("b: "))
# c = a / b  # здесь может возникнуть исключение деления на ноль
# print(c)  # печатаем c = a / b если всё хорошо
# print("После исключения")
# После выполнения этого кода у пользователя может возникнуть такая же ошибка, если он введёт b = 0.

# Так как же сделать так, чтобы программа не вылетала при ошибке и продолжала свою работу?
# Это всё делается очень просто.
# Для этого и нужна конструкция try-except.

print("Пример 1")
# Добавляем конструкцию try-except для отлова нашей ошибки
try:
    print("Перед исключением")
    a = int(input("Enter a:"))
    b = int(input("Enter b:"))
    c = a / b  # здесь может возникнуть исключение деления на ноль
    print(c)  # печатаем c = a / b если всё хорошо
except ZeroDivisionError as e:  # Добавляем тип именно той ошибки которую хотим отловить.
    print(e)  # Выводим информацию об ошибке
    print("После исключения")

print("После блока try-except")
print()
# В данном случае тоже может возникнуть ошибка деления на ноль, если пользователь введёт b = 0.
# Поэтому мы отлавливаем ошибку ZeroDivisionError.
# В блоке try помещается «опасный» кусок кода, который может вызывать исключения,
# а в блоке except указывается класс ошибки, которую мы хотим отловить, а затем помещается код,
# который нужно выполнить в случае возникновении ошибки.
# В данном случае после возникновении ошибки код в блоке try прервётся, перейдёт в блок except,
# а затем продолжит выполняться дальше, т.е. программа не вылетает, как это было без обработчика исключений.
# В этом и есть главная суть конструкции try-except.

# Есть также блоки finally и else.
# try:
#     *ваш код*
# except Ошибка:
#     *Код отлова*
# else:
#     *Код, который выполнится если всё хорошо прошло в блоке try*
# finally:
#     *Код, который выполнится в любом случае*

# ВАЖНО!  Обратите внимание на отступы! Код внутри конструкции сдвинут на второй уровень вложенности.
print("Пример 2")
try:
    print("Перед исключением")
    a = int(input("a: "))
    b = int(input("b: "))
    c = a / b
    print(c)  # печатаем c = a / b если всё хорошо
except ZeroDivisionError as e:
    print("После исключения")
else:  # код в блоке else выполняется только в том случае, если код в блоке try выполнился успешно (т.е. не вылетело никакого исключения).
    print("Всё ништяк")
finally:  # код в блоке finally выполнится в любом случае, при выходе из try-except
    print("Finally на месте")

print("После После исключения")
print()

# мы можем вызывать ошибки самостоятельно, с помощью конструкции raise.
# Используется это, как правило, для отладки кода, и остановки программы в критических ситуациях.
print("Пример raise")
age = int(input("Сколько тебе лет?"))

if age > 100 or age <= 0:
    raise ValueError("Тебе не может быть столько лет!")
print(f"Тебе {age} лет!")
print()
# Здесь ошибка ValueError возникнет, если пользователь ввёл неправильный возраст,
# и остановит работу программы выдав в консоль ошибку и текст, написанный в блоке raise

# Ну и конечно же стоит отметить, что отлавливать вызываемые с помощью raise ошибки тоже можно.
print("Пример raise - 2")
try:
    age = int(input("Сколько тебе лет?"))

    if age > 100 or age <= 0:
        raise ValueError("Тебе не может быть столько лет!")
    print(f"Тебе {age} лет!")
except ValueError:
    print("Не верный возраст")
print()

# краткий итог:
#     1. Исключения — это ошибки, которые выбрасываются при неправильной работе программы,
#        и останавливают её выполнение, если они не обработаны.
#     2. Конструкция try-except выглядит следующим образом и служит для обработки исключений:
#        try:
#            *код, который может вызвать ту или иную ошибку*
#        except *ошибка*:
#            *код, который выполнится в случае возникновения ошибки*
#        else:
#            *код, который выполнится только в случае если в try ничего не сломалось*
#        finally:
#            *код, который выполнится в любом случае*
#     3. Блоки finally и else, являются не обязательными, но могут быть использованы для вашего удобства.
#        Код из блока finally выполняется в любом случае, независимо от исхода в блоках try-except.
#        Код из блока else выполняется только в случае успешного выполнения кода в try.
#     4. Выбрасывать ошибки можно и по своему желанию с помощью конструкции:
#     raise *Тип ошибки* (сообщение, которое нужно вывести в консоль).

print("Задание 2.4.8")
# Создать скрипт, который будет в input() принимать строки, и их необходимо будет конвертировать в числа,
# добавить try-except на то, чтобы строки могли быть сконвертированы в числа.
# В случае удачного выполнения скрипта написать: «Вы ввели правильное число».
# В конце скрипта обязательно написать: «Выход из программы».
# ПРИМЕЧАНИЕ: Для отлова ошибок используйте try-except, а также блоки finally и else.
try:
    value = input("Enter: ")
    print(int(value))
except ValueError:
    print("Нужно ввести число!")
else:
    print("Вы ввели правильное число!")
finally:
    print("Программа завершена!")
