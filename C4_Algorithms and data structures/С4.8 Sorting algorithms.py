# *****  Алгоритмы сортировки *****
# Данные, которые приходят в программу из внешней среды,
# чаще всего являются несортированными — их порядок ничем не определяется.

# В заключительной части модуля мы рассмотрим некоторые алгоритмы сортировки:
#         Наивная сортировка (чтобы показать, как делать не стоит).
#         Сортировка выбором (чуть менее наивный, но далек от идеала).
#         Сортировка пузырьком (пожалуй, самый понятный в реализации, но далеко не самый эффективный).
#         Сортировка вставками (неплохо).
#         Сортировка слиянием (заметно лучше).
#         Быстрая сортировка (почти идеально!).


# *** Наивная сортировка ***
# Ее основная суть заключается в том, чтобы постоянно перемешивать массив,
# пока не получим подходящую последовательность…
# Звучит очень долго с точки зрения времени выполнения.
# И это правда так, ведь для массива из n элементов нам нужно сделать n! (факториал) перестановок
# и проверить каждую из них.
# Помните, в начале модуля мы говорили про алгоритмы сложности O(n!).
# Сейчас в первый и в последний раз, мы с вами реализуем такой алгоритм.
# print("Алгоритм наивной сортировки")
# import random
# array = [2, 3, 1, 4, 6, 5, 9, 8, 7]
# is_sort = False
# count = 0
# while not is_sort:
#     count += 1
#     random.shuffle(array)
#     is_sort = True
#     for i in range(len(array)-1):
#         if array[i] > array[i+1]:
#             is_sort = False
#             break
#
# print(array)
# print(count)
print()
# Уже для 9 элементов получили какое-то нереальное число. Невозможно представить,
# что будет, если в массиве будет хотя бы 100 элементов.


# *** Сортировка выбором ***
# Следующее решение «в лоб» — каждый раз искать минимальный элемент и ставить его в начало.
# Звучит уже интереснее.
print("Алгоритм сортировки выбором")
array = [2, 3, 1, 4, 6, 5, 9, 8, 7]
for i in range(len(array)):
    idx_min = i
    for j in range(i+1, len(array)):
        if array[j] < array[idx_min]:
            idx_min = j
    if i != idx_min:
        array[i], array[idx_min] = array[idx_min], array[i]
print(array)
# На каждом шаге мы имеем отсортированную (слева) и неотсортированную часть (справа).
# Ищется минимальный элемент в неотсортированной части и меняется местами с элементом
# в начале неотсортированной части.
# И так продолжается, пока не закончится внешний цикл.
print()

print("Задание 4.8.3")
# Модифицируйте описанный алгоритм для сортировки по убыванию.
array = [2, 3, 1, 4, 6, 5, 9, 8, 7]
for i in range(len(array)):
    idx_max = i
    for j in range(i+1, len(array)):
        if array[j] > array[idx_max]:
            idx_max = j
    if i != idx_max:
        array[i], array[idx_max] = array[idx_max], array[i]
print(array)
print()


# *** Сортировка пузырьком ***
# Сортировка пузырьком — самый любимый студентами вид сортировки.
# Его суть сводится к тому, что максимальные элементы шаг за шагом «всплывают» вправо —
# в отсортированную часть массива.
# И по ходу совершаются еще перестановки, если это необходимо,
# ведь каждый раз мы сравниваем только соседние элементы!
print("Сортировка пузырьком")
array = [2, 3, 1, 4, 6, 5, 9, 8, 7]
for i in range(len(array)):
    for j in range(len(array)-i-1):
        if array[j] > array[j+1]:
            array[j], array[j+1] = array[j+1], array[j]
print(array)
# Алгоритм сортировки как пузырьком, так и выбором, имеет среднюю сложность O(n^2),
# потому что мы имеем два вложенных цикла, каждый из которых, в среднем,
# проходится по половине всего количества элементов.

# Пузырек удобен, когда структура имеет не очень большой размер и очень важна скорость написания кода.
# В таком случае пузырек идеален — два цикла, одно условие и один swap (перестановка двух элементов).
# Однако на более крупных массивах пузырек сильно проигрывает другим алгоритмам.
print()


# *** Сортировка вставками ***
# Что должен сделать алгоритм?
#     1. В начале итерации устанавливается ведущий элемент.
#        На первой итерации — самый первый элемент и по умолчанию он считается уже отсортированным.
#     2. Сохраняем ведущий элемент в дополнительную переменную (красный квадрат в анимации).
#     3. Далее происходит поиск места, куда должен встать ведущий элемент
#        в уже отсортированной (левой) части массива.
#        Можно, например, использовать цикл while с условием
#        достижения границы и/или успешным нахождением элемента.
#        Пока условие цикла выполняется, происходит сдвиг каждого элемента вправо.
#     4. По завершении цикла сохраненное значение переменной помещается на освободившееся место.
#        Алгоритм завершается.
print("Алгоритм сортировки вставками")
array = [2, 3, 1, 4, 6, 5, 9, 8, 7]

for i in range(1, len(array)):
    tmp = array[i]
    while i > 0 and array[i-1] > tmp:
        array[i] = array[i-1]
        i -= 1
    array[i] = tmp
print(array)
# Алгоритм сортировки вставками хоть и является также квадратичным по времени (в среднем),
# но имеет меньшие множители (в силу уменьшенного количества тяжелых операций).
# И к тому же очень хорошо работает на почти отсортированных массивах.
print()


# *** Сортировка слиянием ***
# Сначала делим массив пополам (или почти пополам, если в массиве нечетное количество элементов).
# И снова пополам. И снова. Еще раз. Пока не устанете.
# Ладно, на самом деле программа сама это сделает, если использовать рекурсию.
# А выход из рекурсии случится тогда, когда отделенный кусок массива станет размером 1, т. е.
# сократится до одного элемента.
# А один элемент уж точно можно считать отсортированным относительно себя.
# Полпути сортировки можно считать пройденной.

# Дальше — интереснее.
# Нам нужно склеивать обратно расщепленные части массива,
# потому она и называется сортировкой слиянием.
# Итак, имеем два одиночных элемента — сравниваем их и возвращаем на предыдущий уровень рекурсии в нужном порядке.
# Когда имеем больше элементов в каждой из частей, подлежащих слиянию, нужно быть предельно аккуратным:
#         Сравниваем первые элементы.
#         В результирующий массив записываем наименьший.
#         Сравниваем первый элемент в нетронутом и второй элемент из другой части.
#         Сравниваем — склеиваем в результат.
#         И так продолжается, пока не будет достигнут конец одной из частей.
#         Последний штрих — в результирующий массив записать все элементы из еще пока непустой части.
#
print("Сортировка слиянием")
array = [2, 3, 1, 4, 6, 5, 9, 8, 7]


# функция сортировки слиянием
def merge_sort(arr):
    if len(arr) < 2:  # если в массиве один элемент
        return arr[:]  # возвращаем массив
    else:  # иначе
        middle = len(arr) // 2  # находим примерную середину массива
        left = merge_sort(arr[:middle])  # задаем левую часть
        right = merge_sort(arr[middle:])  # задаем правую часть
        return merge(left, right)  # вызываем функцию слияния, передав правую и левую части


# функция слияния
def merge(left, right):
    result = []  # создаем пустой список для возврата результата
    i, j = 0, 0  # задаем элементы == 0
    # пока i меньше значения длины левой части и j меньше правой:
    while i < len(left) and j < len(right):
        # если i-тый элемент слева меньше j-того элемента справа
        if left[i] < right[j]:
            # добавляем i-тый элемент из левой части в результирующий список
            result.append(left[i])
            # и увеличиваем i на 1
            i += 1
        # иначе
        else:
            # записываем в результат j-тый элемент из правой части
            result.append(right[j])
            j += 1
    # после завершения первого цикла:
    # пока i меньше длины левой части:
    while i < len(left):
        # записываем элемент из левой части в результат
        result.append(left[i])
        # и переходим к следующему элементу
        i += 1
    # потом, делаем то же самое с правой частью
    while j < len(right):
        result.append(right[j])
        j += 1
    # в конце, возвращаем список
    return result


print(merge_sort(array))
print()

# *** Быстрая сортировка ***
# Быстрая сортировка так же, как и сортировка слиянием, является одной из самых быстрых.
# Она так же основана на принципе «разделяй и властвуй».
# Однако вместо разделения массивов на части и дальнейшего слияния здесь используется другой подход.
# Алгоритм выполняется рекурсивно следующим образом:

#     Выбирается ведущий элемент (есть несколько вариантов, о которых поговорим чуть позже).

#     Две части массива сортируются только на основе этого ведущего элемента.

#     Происходит последовательный обмен значениями элементов.
#     Вопрос в том, какие элементы обменивать.
#     Сначала происходит поиск слева направо до первого элемента,
#     который превосходит по своему значению ведущий элемент.
#     Затем массив просматривается справа налево в поисках элемента,
#     который меньше ведущего. Когда такие элементы найдены, происходит их обмен.

#     Таким образом, в левой части массива имеются элементы только меньше ведущего, а в правой — только больше.

#     Функция рекурсивно применяется к получившимся частям массива, если их размеры превосходят один элемент.
print("Быстрая сортировка")
array = [2, 3, 1, 4, 6, 5, 9, 8, 7]


def qsort(arr, left, right):
    middle = (left + right) // 2
    p = arr[middle]
    i, j = left, right
    while i <= j:
        while arr[i] < p:
            i += 1
        while arr[j] > p:
            j -= 1
        if i <= j:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1
            j -= 1
    if j > left:
        qsort(arr, left, j)
    if right > i:
        qsort(arr, i, right)
    return arr


print(qsort(array, 4, 6))

print("Задание 4.8.7")
import random

array = [2, 3, 1, 4, 6, 5, 9, 8, 7]

def qsort_random(arr, left, right):
    p = random.choice(array[left:right + 1])
    count = 0
    i, j = left, right
    while i <= j:
        while array[i] < p:
            i += 1
        while array[j] > p:
            j -= 1
        if i <= j:
            count += 1
            array[i], array[j] = array[j], array[i]
            i += 1
            j -= 1

    if j > left:
        qsort_random(array, left, j)
    if right > i:
        qsort_random(array, i, right)

print(qsort_random(array, 2, 7))