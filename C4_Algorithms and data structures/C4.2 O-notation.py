# ***** О-нотация *****
# критериями эффективности или, иначе, сложности алгоритмов являются временной и пространственный.

# Временная сложность алгоритма говорит нам о том, какое количество времени
# может потребоваться для выполнения этого алгоритма.
# И, естественно, она зависит от размера входных данных — точно также, как уборка от площади квартиры.

# Пространственная сложность алгоритма связана с количеством памяти, которое он использует в ходе своей работы.
# Здесь работает та же аналогия с приготовлением ужина —
# зависимость от количества посуды, которая загрязняется из-за готовки.
#
# Здесь и далее в основном будем говорить о временной сложности алгоритмов
# и в некоторых случаях затрагивать пространственную, когда это будет необходимо.


# *** Алгоритмы различной сложности ***
# Самый простой, самый эффективный алгоритм, к которому все стремятся, — это константный алгоритм.
# Константным, или постоянным по времени, называется алгоритм,
# который выполняет необходимое действие всегда за одинаковое количество времени
# (с точностью до небольшого множителя, вызванного техническими характеристиками вычислительной машины).
# К таким «алгоритмам» относят очень простые операции:
#   присваивание;
#   арифметические операции;
#   логические операции;
#   сравнение объектов;

# чем больше элементов, тем больше времени нужно, и, более того,
# количество времени возрастает в тоже самое количество раз, как и размер списка.
# Такие алгоритмы называют линейными.

# Бывают ситуации, когда алгоритмы могут работать быстрее, чем линейные:
# самые распространенные — это логарифмические алгоритмы.
# Их название напрямую связано с тем, как возрастает временная сложность алгоритма с ростом размера входных данных.

# Линейный алгоритм является частным случаем полиномиальных алгоритмов, а всех их объединяет,
# что для обработки n объектов входных данных (чисел, например) требуется n^k операций.


# *** Алгоритмическая троица: «О» большая, омега, тета ***
# Для оценки сложности алгоритмов вводятся 3 математические величины:
#         «О» большая — верхняя оценка сложности алгоритма;
#         «Ω» (омега) — нижняя оценка сложности;
#         «Θ» (тета) — точная оценка сложности.

# Мы рассматривали ранее примеры различных алгоритмов — константные, логарифмические, линейные.
# При помощи символа «О» можно записать так называемую асимптотическую сложность алгоритма.
# Такое обозначение имеет сильную математическую базу, но для нас это важно тем, что это удобная краткая запись.
# Общепринято оценивать, насколько «проблемный» алгоритм, именно с помощью такого символа.

# Сложность алгоритма 	О-нотация 	Примеры
# Константная 	          O(1) 	    Сложение, присваивание
# Логарифмическая 	    O(log(n)) 	Разрезание бумаги на части
# Линейная 	              O(n) 	    Поиск максимального элемента из списка
# Квадратичная 	         O(n^2) 	Расстановка книг в алфавитном порядке
# Полиномиальная 	     O(n^k) 	Про такие алгоритмы лучше забыть
# Факториальная 	      O(n!) 	А такие наводят ужас на всех программистов

# Правила работы с О-нотацией
# Существует несколько правил, облегчающих анализ алгоритмов при помощи
# О-нотации.
# ● Сумма. “О” большое суммы функций является эквивалентным “О” большому от
# наиболее быстрой функции. Пример:
# O(n^2+n^3) = O(n^3)
# ● Произведение. Произведение “О” большого от функций равно “О” большому от
# произведения этих функций. Пример:
# O(n)*O(log(n)) = O(n*log(n))
# ● Умножение на число. Числовой множитель не влияет на асимптотическую
# сложность
# 5*O(n) = O(5n) = O(n)
