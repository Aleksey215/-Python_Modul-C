# ***** Основные структуры данных *****
# Структура данных — это программная единица,
# позволяющая хранить и обрабатывать множество логически связанных объектов.
# В этой части модуля мы начнем рассмотрение с основных и уже знакомых нам (под другими именами) структур данных:
#
#         массивы: статические и динамические;
#         хэш-таблицы.
#
# Каждую структуру данных в этом юните и в следующих мы будем рассматривать
# с точки зрения ее хранения в памяти, и, в зависимости от этого, как реализуются основные функции работы с ними:
#
#         доступ к элементу по индексу;
#         вставка элемента;
#         удаление элемента;
#         получение размера структуры.
#
# А также для каждой структуры, возможно, будут определяться специфичные для нее функции.

# *** Массивы ***
# Массив — это упорядоченный набор данных.
# Под упорядоченностью стоит понимать, что хранение этой структуры в памяти каким-то образом организовано.
# Массивы, для которых заранее резервируется фиксированная область памяти, называют статическими.
# В отличие от них существуют динамические массивы,
# которые с помощью буферного механизма, могут изменять свой размер.

# Важно различать:
#         логический размер массива (logical size) — фактическая заполненность массива;
#         зарезервированный размер памяти (capacity) — вместимость памяти для этого массива.

# Наиболее выгодное использование массивов возникает в тех ситуациях,
# когда происходит частое обращение к элементам массива по индексам,
# и в меньшей степени возникает необходимость добавлять и удалять элементы на произвольное место.

# Асимптотическая сложность некоторых операций массива:
# Получение размера 	O(1)
# Получение элемента массива по индексу 	O(1)
# Вставка элемента в конец / удаление с конца 	O(1)
# Вставка элемента на произвольное место / удаление элемента из произвольного места 	O(n)
# Расширение памяти при выходе за пределы массива 	O(n)

# *** Хэш-таблицы ***
# Словарный тип данных, с которым мы уже хорошо знакомы,
# реализует принцип структурирования данных, называющийся хэш-таблицы.
# Его суть заключается в том, что каждое значение обладает ключом доступа к нему.
# Тогда имеем, что все значения хранятся в обычном массиве (скрытом от нас),
# а в качестве индекса используется результат хэширования ключа.

# В данном случае под хэшированием понимается преобразование объекта,
# выступающего ключом, в целое число — индекс, используемый для доступа к значению.

# ключ должен быть уникальным, а также неизменяемым.
# Только обладая этими двумя условиями, хэш-таблица сможет корректно восстановить данные по ключу.

# Вставка пары 	                dict_[new_key] = value 	 O(1)
# Удаление пары 	            dict_.pop(key) 	         O(1)
# Получение значения по ключу 	dict_[key]               O(1)
# или                           dict_.get(key) 	         O(1)
# Получение размера 	        len(dict) 	             O(n)

# Вставка пары происходит за константное время, потому что порядок элемента
# во внутреннем массиве не принципиален для словаря.
# Главное, чтобы по хэш-таблице его однозначно можно было воспроизвести, а сама операция хэширования стоит O(1).

# Удаление пары и получение значения по ключу также будет стоить константное время.
# Всё, что необходимо сделать — получить хэш ключа (и именно он стоит константное время),
# который является индексом массива. А мы уже знаем, что индексирование также требует O(1) времени.

# Для получения размера словаря необходимо пересчитать все ключи.
# В связи с тем, что хранение размера такой структуры данных не подразумевается,
# а внутренний массив может быть разреженным (иметь пропуски),
# придется циклом перебрать список ключей, посчитав их количество.
# Раз имеем цикл по всем элементам, значит сложность операции — O(n).

# Казалось бы, все основные операции: доступ, вставка, удаление — занимают константное время.
# Почему словари (ассоциативные массивы или хэш-таблицы) не используют везде?!
# Дело в том, что хоть они и занимают константное время асимптотически,
# но сами операции более тяжеловесны как по памяти, так и по времени,
# нежели аналогичные в других структурах данных.
# Помимо этого, для реализации такой структуры данных требуется дополнительная память и,
# как правило, сильно больше, чем для других структур.
# Здесь, как и в других случаях, нужно искать оптимум между производительностью и памятью.
# Несмотря на это хэш-таблицы действительно имеют огромную область применения.
# С некоторыми возможностями мы уже знакомились, но особо полезны такие структуры в работе с базами данных.